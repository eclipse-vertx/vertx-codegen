package io.vertx.codegen.protobuf.generator;

import io.vertx.codegen.*;
import io.vertx.codegen.protobuf.annotations.FieldNumberStrategy;
import io.vertx.codegen.protobuf.annotations.JsonProtoEncoding;
import io.vertx.codegen.protobuf.annotations.ProtobufGen;
import io.vertx.codegen.type.ClassKind;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class ProtoFileGen extends Generator<Model> {

  public ProtoFileGen() {
    name = "protobuf";
    kinds = new HashSet<>();
    kinds.add("dataObject");
    kinds.add("enum");
    incremental = true;
  }

  @Override
  public Collection<Class<? extends Annotation>> annotations() {
    return Arrays.asList(ProtobufGen.class);
  }

  @Override
  public String filename(Model model) {
    if ((model instanceof DataObjectModel || model instanceof EnumModel)
      && model.getAnnotations().stream().anyMatch(ann -> ann.getName().equals(ProtobufGen.class.getName()))) {
      return "resources/dataobjects.proto";
    }
    return null;
  }

  @Override
  public String render(Model model, int index, int size, Map<String, Object> session) {
    if (model instanceof EnumModel) {
      return renderEnumModel((EnumModel) model, index);
    } else if (model instanceof DataObjectModel) {
      return renderDataObjectModel((DataObjectModel) model, index);
    } else {
      throw new RuntimeException("Unsupported model type " + model.getClass().getName());
    }
  }

  private String renderEnumModel(EnumModel model, int index) {
    StringWriter buffer = new StringWriter();
    PrintWriter writer = new PrintWriter(buffer);
    int enumIntValue = 0; // auto-increment for now
    writer.print("enum " + model.getElement().getSimpleName() + " {\n");
    for (EnumValueInfo enumValueInfo: model.getValues()) {
      writer.print("  " + enumValueInfo.getIdentifier() + " = " + enumIntValue + ";\n");
      enumIntValue++;
    }
    writer.print("}\n");
    writer.print("\n");
    return buffer.toString();
  }

  private String renderDataObjectModel(DataObjectModel model, int index) {
    StringWriter buffer = new StringWriter();
    PrintWriter writer = new PrintWriter(buffer);

    JsonProtoEncoding jsonProtoEncoding = ProtobufGenAnnotation.jsonProtoEncoding(model);
    FieldNumberStrategy fieldNumberStrategy = ProtobufGenAnnotation.fieldNumberStrategy(model);
    Set<Integer> reservedFieldNumbers = ProtobufGenAnnotation.reservedFieldNumbers(model);
    Set<String> reservedFieldNames = ProtobufGenAnnotation.reservedFieldNames(model);

    if (index == 0) {
      writer.print("// Automatically generated by vertx-codegen.\n");
      writer.print("// Do not edit. Changes made to this file may be overwritten.\n");
      writer.print("\n");
      writer.print("syntax = \"proto3\";\n");
      writer.print("option java_multiple_files = true;\n");
      writer.print("option java_package = \"io.vertx.protobuf.generated\";\n");
      writer.print("\n");
      writer.print("package io.vertx.protobuf.generated;\n");
      writer.print("\n");
      if (jsonProtoEncoding == JsonProtoEncoding.GOOGLE_STRUCT) {
        writer.print("import \"struct.proto\";\n");
      } else {
        writer.print("import \"vertx-struct.proto\";\n");
      }
      writer.print("import \"datetime.proto\";\n");
      writer.print("\n");
    }

    String messageName = model.getType().getSimpleName();

    Collection<PropertyInfo> properties = model.getPropertyMap().values();
    ProtobufFields.verifyFieldNames(properties, reservedFieldNames);
    Map<String, Integer> fieldNumbers = ProtobufFields.fieldNumbers(properties, fieldNumberStrategy, reservedFieldNumbers);
    List<PropertyInfo> orderedProperties = ProtobufFields.inFieldNumberOrder(properties, fieldNumbers);

    writer.print("message " + messageName + " {\n");

    if (!reservedFieldNumbers.isEmpty()) {
      writer.print("  reserved ");
      writer.print(reservedFieldNumbers.stream()
        .sorted()
        .map(it -> "" + it)
        .collect(Collectors.joining(", ")));
      writer.print(";\n");
    }
    if (!reservedFieldNames.isEmpty()) {
      writer.print("  reserved ");
      writer.print(reservedFieldNames.stream()
        .sorted()
        .map(it -> '"' + it + '"')
        .collect(Collectors.joining(", ")));
      writer.print(";\n");
    }

    for (PropertyInfo prop : orderedProperties) {
      ClassKind propKind = prop.getType().getKind();
      int fieldNumber = fieldNumbers.get(prop.getName());
      ProtoProperty protoProperty = ProtoProperty.getProtoProperty(prop, fieldNumber);

      String protoFieldType;
      if (propKind.basic) {
        protoFieldType = protoProperty.getProtoType().value;
      } else {
        if (prop.getType().getKind() == ClassKind.ENUM) {
            protoFieldType = protoProperty.getEnumType();
        } else { // Not Enum
          if (protoProperty.isBuiltinType()) {
            protoFieldType = "io.vertx.protobuf." + protoProperty.getBuiltInType();
          } else {
            protoFieldType = protoProperty.getMessage();
          }
        }
      }

      if (prop.getKind().isList()) {
        writer.print("  repeated " + protoFieldType + " " + prop.getName() + " = " + fieldNumber + ";\n");
      } else if (prop.getKind().isMap()) {
        writer.print("  map<string, " + protoFieldType + "> " + prop.getName() + " = " + fieldNumber + ";\n");
      } else {
        writer.print("  " + protoFieldType + " " + prop.getName() + " = " + fieldNumber + ";\n");
      }
    }
    writer.print("}\n");
    writer.print("\n");

    return buffer.toString();
  }
}
